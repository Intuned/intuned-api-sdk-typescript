/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { remap as remap$ } from "../../lib/primitives";
import { ClosedEnum } from "../../types";
import { AuthSession, AuthSession$ } from "./authsession";
import { JobConfiguration, JobConfiguration$ } from "./jobconfiguration";
import { JobPayload, JobPayload$ } from "./jobpayload";
import { JobSchedule, JobSchedule$ } from "./jobschedule";
import { JobSink, JobSink$ } from "./jobsink";
import * as z from "zod";

export const JobStateStatus = {
    Paused: "PAUSED",
} as const;
export type JobStateStatus = ClosedEnum<typeof JobStateStatus>;

export type Paused = {
    status?: JobStateStatus | undefined;
    /**
     * The reason the job is paused
     */
    reason?: string | undefined;
};

export const StateStatus = {
    Active: "ACTIVE",
} as const;
export type StateStatus = ClosedEnum<typeof StateStatus>;

export type Active = {
    status?: StateStatus | undefined;
};

export type State = Active | Paused;

/**
 * Job properties and configurations
 */
export type Job = {
    /**
     * The ID of the job. Has to be a valid URL slug.
     */
    id: string;
    /**
     * The configuration of the job. Configures the retry policy and maximum concurrent requests.
     */
    configuration: JobConfiguration;
    /**
     * A sink to send the results to. Can be a webhook or Amazon S3 bucket.
     */
    sink?: JobSink | null | undefined;
    /**
     * A list of the initial payloads of the job.
     */
    payload: Array<JobPayload>;
    /**
     * Schedule configurations for the job. If set, the job will periodically run according to this configuration. The configurations are used to calculate the closest next run time.
     */
    schedule?: JobSchedule | undefined;
    /**
     * Auth session configurations
     */
    authSession?: AuthSession | undefined;
    /**
     * The timestamp of when the job was created.
     */
    createdAt?: Date | undefined;
    /**
     * The timestamp of the next scheduled job run. `null` if the job does not have a schedule.
     */
    nextRunTime: Date | null;
    /**
     * The timestamp of the last time the job ran. `null` if the job has not run yet.
     */
    lastRunTime: Date | null;
    state: Active | Paused;
    /**
     * The project ID of the job
     */
    projectId: string;
};

/** @internal */
export namespace JobStateStatus$ {
    export const inboundSchema = z.nativeEnum(JobStateStatus);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace Paused$ {
    export const inboundSchema: z.ZodType<Paused, z.ZodTypeDef, unknown> = z.object({
        status: JobStateStatus$.inboundSchema.optional(),
        reason: z.string().optional(),
    });

    export type Outbound = {
        status?: string | undefined;
        reason?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Paused> = z.object({
        status: JobStateStatus$.outboundSchema.optional(),
        reason: z.string().optional(),
    });
}

/** @internal */
export namespace StateStatus$ {
    export const inboundSchema = z.nativeEnum(StateStatus);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace Active$ {
    export const inboundSchema: z.ZodType<Active, z.ZodTypeDef, unknown> = z.object({
        status: StateStatus$.inboundSchema.optional(),
    });

    export type Outbound = {
        status?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Active> = z.object({
        status: StateStatus$.outboundSchema.optional(),
    });
}

/** @internal */
export namespace State$ {
    export const inboundSchema: z.ZodType<State, z.ZodTypeDef, unknown> = z.union([
        z.lazy(() => Active$.inboundSchema),
        z.lazy(() => Paused$.inboundSchema),
    ]);

    export type Outbound = Active$.Outbound | Paused$.Outbound;
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, State> = z.union([
        z.lazy(() => Active$.outboundSchema),
        z.lazy(() => Paused$.outboundSchema),
    ]);
}

/** @internal */
export namespace Job$ {
    export const inboundSchema: z.ZodType<Job, z.ZodTypeDef, unknown> = z
        .object({
            id: z.string(),
            configuration: JobConfiguration$.inboundSchema,
            sink: z.nullable(JobSink$.inboundSchema).optional(),
            payload: z.array(JobPayload$.inboundSchema),
            schedule: JobSchedule$.inboundSchema.optional(),
            authSession: AuthSession$.inboundSchema.optional(),
            created_at: z
                .string()
                .datetime({ offset: true })
                .transform((v) => new Date(v))
                .optional(),
            next_run_time: z.nullable(
                z
                    .string()
                    .datetime({ offset: true })
                    .transform((v) => new Date(v))
            ),
            last_run_time: z.nullable(
                z
                    .string()
                    .datetime({ offset: true })
                    .transform((v) => new Date(v))
            ),
            state: z.union([
                z.lazy(() => Active$.inboundSchema),
                z.lazy(() => Paused$.inboundSchema),
            ]),
            projectId: z.string(),
        })
        .transform((v) => {
            return remap$(v, {
                created_at: "createdAt",
                next_run_time: "nextRunTime",
                last_run_time: "lastRunTime",
            });
        });

    export type Outbound = {
        id: string;
        configuration: JobConfiguration$.Outbound;
        sink?: JobSink$.Outbound | null | undefined;
        payload: Array<JobPayload$.Outbound>;
        schedule?: JobSchedule$.Outbound | undefined;
        authSession?: AuthSession$.Outbound | undefined;
        created_at?: string | undefined;
        next_run_time: string | null;
        last_run_time: string | null;
        state: Active$.Outbound | Paused$.Outbound;
        projectId: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Job> = z
        .object({
            id: z.string(),
            configuration: JobConfiguration$.outboundSchema,
            sink: z.nullable(JobSink$.outboundSchema).optional(),
            payload: z.array(JobPayload$.outboundSchema),
            schedule: JobSchedule$.outboundSchema.optional(),
            authSession: AuthSession$.outboundSchema.optional(),
            createdAt: z
                .date()
                .transform((v) => v.toISOString())
                .optional(),
            nextRunTime: z.nullable(z.date().transform((v) => v.toISOString())),
            lastRunTime: z.nullable(z.date().transform((v) => v.toISOString())),
            state: z.union([
                z.lazy(() => Active$.outboundSchema),
                z.lazy(() => Paused$.outboundSchema),
            ]),
            projectId: z.string(),
        })
        .transform((v) => {
            return remap$(v, {
                createdAt: "created_at",
                nextRunTime: "next_run_time",
                lastRunTime: "last_run_time",
            });
        });
}
