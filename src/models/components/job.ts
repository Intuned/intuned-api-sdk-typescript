/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { remap as remap$ } from "../../lib/primitives";
import { ClosedEnum } from "../../types";
import { AuthSession, AuthSession$ } from "./authsession";
import { JobConfiguration, JobConfiguration$ } from "./jobconfiguration";
import { JobPayload, JobPayload$ } from "./jobpayload";
import { JobSchedule, JobSchedule$ } from "./jobschedule";
import { JobSink, JobSink$ } from "./jobsink";
import * as z from "zod";

export const JobStateStatus = {
    Paused: "PAUSED",
} as const;
export type JobStateStatus = ClosedEnum<typeof JobStateStatus>;

export type Two = {
    status?: JobStateStatus | undefined;
    /**
     * The reason the job is paused
     */
    reason?: string | undefined;
};

export const StateStatus = {
    Active: "ACTIVE",
} as const;
export type StateStatus = ClosedEnum<typeof StateStatus>;

export type One = {
    status?: StateStatus | undefined;
};

export type State = One | Two;

/**
 * Job properties and configurations
 */
export type Job = {
    /**
     * The ID of the job. Has to be a valid URL slug.
     */
    id: string;
    /**
     * The configuration of the job. Configures the retry policy and maximum concurrent requests.
     */
    configuration: JobConfiguration;
    /**
     * A sink to send the results to. Can be a webhook or Amazon S3 bucket.
     */
    sink?: JobSink | undefined;
    /**
     * A list of the initial payloads of the job.
     */
    payload: Array<JobPayload>;
    /**
     * Schedule configurations for the job. If set, the job will periodically run according to this configuration. The configurations are used to calculate the closest next run time.
     */
    schedule?: JobSchedule | undefined;
    /**
     * Auth session configurations
     */
    authSession?: AuthSession | undefined;
    /**
     * The timestamp of when the job was created.
     */
    createdAt?: Date | undefined;
    /**
     * The timestamp of the next scheduled job run. `null` if the job does not have a schedule.
     */
    nextRunTime?: Date | null | undefined;
    /**
     * The timestamp of the last time the job ran.
     */
    lastRunTime?: Date | undefined;
    state: One | Two;
    /**
     * The project ID of the job
     */
    projectId: string;
};

/** @internal */
export namespace JobStateStatus$ {
    export const inboundSchema = z.nativeEnum(JobStateStatus);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace Two$ {
    export const inboundSchema: z.ZodType<Two, z.ZodTypeDef, unknown> = z.object({
        status: JobStateStatus$.inboundSchema.optional(),
        reason: z.string().optional(),
    });

    export type Outbound = {
        status?: string | undefined;
        reason?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Two> = z.object({
        status: JobStateStatus$.outboundSchema.optional(),
        reason: z.string().optional(),
    });
}

/** @internal */
export namespace StateStatus$ {
    export const inboundSchema = z.nativeEnum(StateStatus);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace One$ {
    export const inboundSchema: z.ZodType<One, z.ZodTypeDef, unknown> = z.object({
        status: StateStatus$.inboundSchema.optional(),
    });

    export type Outbound = {
        status?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, One> = z.object({
        status: StateStatus$.outboundSchema.optional(),
    });
}

/** @internal */
export namespace State$ {
    export const inboundSchema: z.ZodType<State, z.ZodTypeDef, unknown> = z.union([
        z.lazy(() => One$.inboundSchema),
        z.lazy(() => Two$.inboundSchema),
    ]);

    export type Outbound = One$.Outbound | Two$.Outbound;
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, State> = z.union([
        z.lazy(() => One$.outboundSchema),
        z.lazy(() => Two$.outboundSchema),
    ]);
}

/** @internal */
export namespace Job$ {
    export const inboundSchema: z.ZodType<Job, z.ZodTypeDef, unknown> = z
        .object({
            id: z.string(),
            configuration: JobConfiguration$.inboundSchema,
            sink: JobSink$.inboundSchema.optional(),
            payload: z.array(JobPayload$.inboundSchema),
            schedule: JobSchedule$.inboundSchema.optional(),
            authSession: AuthSession$.inboundSchema.optional(),
            created_at: z
                .string()
                .datetime({ offset: true })
                .transform((v) => new Date(v))
                .optional(),
            next_run_time: z
                .nullable(
                    z
                        .string()
                        .datetime({ offset: true })
                        .transform((v) => new Date(v))
                )
                .optional(),
            last_run_time: z
                .string()
                .datetime({ offset: true })
                .transform((v) => new Date(v))
                .optional(),
            state: z.union([z.lazy(() => One$.inboundSchema), z.lazy(() => Two$.inboundSchema)]),
            projectId: z.string(),
        })
        .transform((v) => {
            return remap$(v, {
                created_at: "createdAt",
                next_run_time: "nextRunTime",
                last_run_time: "lastRunTime",
            });
        });

    export type Outbound = {
        id: string;
        configuration: JobConfiguration$.Outbound;
        sink?: JobSink$.Outbound | undefined;
        payload: Array<JobPayload$.Outbound>;
        schedule?: JobSchedule$.Outbound | undefined;
        authSession?: AuthSession$.Outbound | undefined;
        created_at?: string | undefined;
        next_run_time?: string | null | undefined;
        last_run_time?: string | undefined;
        state: One$.Outbound | Two$.Outbound;
        projectId: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Job> = z
        .object({
            id: z.string(),
            configuration: JobConfiguration$.outboundSchema,
            sink: JobSink$.outboundSchema.optional(),
            payload: z.array(JobPayload$.outboundSchema),
            schedule: JobSchedule$.outboundSchema.optional(),
            authSession: AuthSession$.outboundSchema.optional(),
            createdAt: z
                .date()
                .transform((v) => v.toISOString())
                .optional(),
            nextRunTime: z.nullable(z.date().transform((v) => v.toISOString())).optional(),
            lastRunTime: z
                .date()
                .transform((v) => v.toISOString())
                .optional(),
            state: z.union([z.lazy(() => One$.outboundSchema), z.lazy(() => Two$.outboundSchema)]),
            projectId: z.string(),
        })
        .transform((v) => {
            return remap$(v, {
                createdAt: "created_at",
                nextRunTime: "next_run_time",
                lastRunTime: "last_run_time",
            });
        });
}
