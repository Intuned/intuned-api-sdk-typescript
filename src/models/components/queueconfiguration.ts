/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { QueueRetry, QueueRetry$ } from "./queueretry";
import * as z from "zod";

export enum QueueConfigurationRunMode {
    Default = "Default",
}

export type RateLimits = {
    limit: number;
    duration: string;
};

export type Schedule = {
    pause: string;
    resume: string;
};

export type Two = {
    min: string;
    max: string;
};

export type One = {
    min: number;
    max: number;
};

export type RandomWait = One | Two;

export type QueueConfiguration = {
    runMode: QueueConfigurationRunMode;
    retry?: QueueRetry | undefined;
    rateLimits?: Array<RateLimits> | undefined;
    schedule?: Schedule | undefined;
    randomWait?: One | Two | undefined;
};

/** @internal */
export namespace QueueConfigurationRunMode$ {
    export const inboundSchema = z.nativeEnum(QueueConfigurationRunMode);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace RateLimits$ {
    export const inboundSchema: z.ZodType<RateLimits, z.ZodTypeDef, unknown> = z
        .object({
            limit: z.number(),
            duration: z.string(),
        })
        .transform((v) => {
            return {
                limit: v.limit,
                duration: v.duration,
            };
        });

    export type Outbound = {
        limit: number;
        duration: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, RateLimits> = z
        .object({
            limit: z.number(),
            duration: z.string(),
        })
        .transform((v) => {
            return {
                limit: v.limit,
                duration: v.duration,
            };
        });
}

/** @internal */
export namespace Schedule$ {
    export const inboundSchema: z.ZodType<Schedule, z.ZodTypeDef, unknown> = z
        .object({
            pause: z.string(),
            resume: z.string(),
        })
        .transform((v) => {
            return {
                pause: v.pause,
                resume: v.resume,
            };
        });

    export type Outbound = {
        pause: string;
        resume: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Schedule> = z
        .object({
            pause: z.string(),
            resume: z.string(),
        })
        .transform((v) => {
            return {
                pause: v.pause,
                resume: v.resume,
            };
        });
}

/** @internal */
export namespace Two$ {
    export const inboundSchema: z.ZodType<Two, z.ZodTypeDef, unknown> = z
        .object({
            min: z.string(),
            max: z.string(),
        })
        .transform((v) => {
            return {
                min: v.min,
                max: v.max,
            };
        });

    export type Outbound = {
        min: string;
        max: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Two> = z
        .object({
            min: z.string(),
            max: z.string(),
        })
        .transform((v) => {
            return {
                min: v.min,
                max: v.max,
            };
        });
}

/** @internal */
export namespace One$ {
    export const inboundSchema: z.ZodType<One, z.ZodTypeDef, unknown> = z
        .object({
            min: z.number(),
            max: z.number(),
        })
        .transform((v) => {
            return {
                min: v.min,
                max: v.max,
            };
        });

    export type Outbound = {
        min: number;
        max: number;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, One> = z
        .object({
            min: z.number(),
            max: z.number(),
        })
        .transform((v) => {
            return {
                min: v.min,
                max: v.max,
            };
        });
}

/** @internal */
export namespace RandomWait$ {
    export const inboundSchema: z.ZodType<RandomWait, z.ZodTypeDef, unknown> = z.union([
        z.lazy(() => One$.inboundSchema),
        z.lazy(() => Two$.inboundSchema),
    ]);

    export type Outbound = One$.Outbound | Two$.Outbound;
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, RandomWait> = z.union([
        z.lazy(() => One$.outboundSchema),
        z.lazy(() => Two$.outboundSchema),
    ]);
}

/** @internal */
export namespace QueueConfiguration$ {
    export const inboundSchema: z.ZodType<QueueConfiguration, z.ZodTypeDef, unknown> = z
        .object({
            runMode: QueueConfigurationRunMode$.inboundSchema,
            retry: QueueRetry$.inboundSchema.optional(),
            rateLimits: z.array(z.lazy(() => RateLimits$.inboundSchema)).optional(),
            schedule: z.lazy(() => Schedule$.inboundSchema).optional(),
            randomWait: z
                .union([z.lazy(() => One$.inboundSchema), z.lazy(() => Two$.inboundSchema)])
                .optional(),
        })
        .transform((v) => {
            return {
                runMode: v.runMode,
                ...(v.retry === undefined ? null : { retry: v.retry }),
                ...(v.rateLimits === undefined ? null : { rateLimits: v.rateLimits }),
                ...(v.schedule === undefined ? null : { schedule: v.schedule }),
                ...(v.randomWait === undefined ? null : { randomWait: v.randomWait }),
            };
        });

    export type Outbound = {
        runMode: string;
        retry?: QueueRetry$.Outbound | undefined;
        rateLimits?: Array<RateLimits$.Outbound> | undefined;
        schedule?: Schedule$.Outbound | undefined;
        randomWait?: One$.Outbound | Two$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, QueueConfiguration> = z
        .object({
            runMode: QueueConfigurationRunMode$.outboundSchema,
            retry: QueueRetry$.outboundSchema.optional(),
            rateLimits: z.array(z.lazy(() => RateLimits$.outboundSchema)).optional(),
            schedule: z.lazy(() => Schedule$.outboundSchema).optional(),
            randomWait: z
                .union([z.lazy(() => One$.outboundSchema), z.lazy(() => Two$.outboundSchema)])
                .optional(),
        })
        .transform((v) => {
            return {
                runMode: v.runMode,
                ...(v.retry === undefined ? null : { retry: v.retry }),
                ...(v.rateLimits === undefined ? null : { rateLimits: v.rateLimits }),
                ...(v.schedule === undefined ? null : { schedule: v.schedule }),
                ...(v.randomWait === undefined ? null : { randomWait: v.randomWait }),
            };
        });
}
