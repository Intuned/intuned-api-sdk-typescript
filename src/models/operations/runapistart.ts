/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type RunApiStartGlobals = {
  /**
   * Your workspace ID. [How to find it](/docs/guides/general/how-to-get-a-workspace-id)?
   */
  workspaceId?: string | undefined;
};

/**
 * Retry policy configurations in case of failure.
 */
export type Retry = {
  /**
   * Maximum number of attempts to retry the run in case of failure
   */
  maximumAttempts?: number | undefined;
};

export type Two = {
  id?: string | undefined;
  autoRecreate?: boolean | undefined;
  /**
   * Number of attempts to check the validity of the auth session before recreating it.
   */
  checkAttempts?: number | undefined;
  /**
   * Number of attempts to create a new auth session if the current one is invalid or expired.
   */
  createAttempts?: number | undefined;
  /**
   * Proxy URL to be used for the API call. This is optional and can be used to route the API call through a proxy server.
   */
  proxy?: string | undefined;
  /**
   * Timeout for the API request in seconds. Default is 10 minutes (600 seconds).
   */
  requestTimeout?: number | undefined;
  /**
   * Runtime input to be used for the auth session. This is optional and can be used to pass dynamic values at runtime.
   */
  runtimeInput: { [k: string]: any };
};

export type One = {
  /**
   * The ID of the auth session to be used.
   */
  id: string;
  /**
   * If true, the auth session will be automatically recreated if it is invalid or expired.
   */
  autoRecreate?: boolean | undefined;
  /**
   * Number of attempts to check the validity of the auth session before recreating it.
   */
  checkAttempts?: number | undefined;
  /**
   * Number of attempts to create a new auth session if the current one is invalid or expired.
   */
  createAttempts?: number | undefined;
  /**
   * Proxy URL to be used for the API call. This is optional and can be used to route the API call through a proxy server.
   */
  proxy?: string | undefined;
  /**
   * Timeout for the API request in seconds. Default is 10 minutes (600 seconds).
   */
  requestTimeout?: number | undefined;
};

/**
 * Auth session config to be used with the run. This is a required field if the auth session is enabled on the project.
 */
export type AuthSession = One | Two;

export const SinkType = {
  S3: "s3",
} as const;
export type SinkType = ClosedEnum<typeof SinkType>;

/**
 * Configuration for the S3 sink.
 */
export type S3SinkConfiguration = {
  type: SinkType;
  /**
   * The name of the S3 bucket where the data will be stored.
   */
  bucket: string;
  /**
   * The access key ID for the S3 bucket.
   */
  accessKeyId: string;
  /**
   * The secret access key for the S3 bucket.
   */
  secretAccessKey: string;
  /**
   * The region where the S3 bucket is located.
   */
  region: string;
  /**
   * Optional prefix for the S3 objects. This can be used to organize objects within the bucket.
   */
  prefix?: string | undefined;
  /**
   * If enabled, failed payload runs will ***not*** be written to the bucket.
   */
  skipOnFail?: boolean | undefined;
  /**
   * List of API names to be sent to the S3 bucket. If not provided, all APIs will be sent.
   */
  apisToSend?: Array<string> | undefined;
  /**
   * Optional custom endpoint for the S3 bucket. This can be used for S3-compatible services.
   */
  endpoint?: string | undefined;
  /**
   * If true, the S3 client will use path-style URLs instead of virtual-hosted-style URLs. This is useful for S3-compatible services that require path-style access.
   */
  forcePathStyle?: boolean | undefined;
};

export const Type = {
  Webhook: "webhook",
} as const;
export type Type = ClosedEnum<typeof Type>;

/**
 * Configuration for the webhook sink.
 */
export type WebhookSinkConfiguration = {
  type: Type;
  /**
   * The URL to which the webhook will send the data.
   */
  url: string;
  /**
   * Optional headers to be sent with the webhook request.
   */
  headers?: { [k: string]: string } | undefined;
  /**
   * If true, the webhook will not be sent if the API execution fails.
   */
  skipOnFail?: boolean | undefined;
  /**
   * List of API names to be sent to the webhook. If not provided, all APIs will be sent.
   */
  apisToSend?: Array<string> | undefined;
};

/**
 * Optional sink configuration for the run. Can be a webhook or S3 sink.
 */
export type Sink = S3SinkConfiguration | WebhookSinkConfiguration;

/**
 * Run API input schema
 */
export type RunApiStartRequestBody = {
  /**
   * The parameters to be passed to the API.
   */
  parameters: { [k: string]: any };
  /**
   * Proxy URL to be used for the API call. This is optional and can be used to route the API call through a proxy server.
   */
  proxy?: string | undefined;
  saveTrace?: boolean | undefined;
  /**
   * Timeout for the API request in seconds. Default is 10 minutes (600 seconds).
   */
  requestTimeout?: number | undefined;
  /**
   * Retry policy configurations in case of failure.
   */
  retry?: Retry | undefined;
  /**
   * Auth session config to be used with the run. This is a required field if the auth session is enabled on the project.
   */
  authSession?: One | Two | undefined;
  /**
   * Optional sink configuration for the run. Can be a webhook or S3 sink.
   */
  sink?: S3SinkConfiguration | WebhookSinkConfiguration | undefined;
  /**
   * The name of the API to be executed. This is the file path relative to the `api` folder inside your project.
   */
  api: string;
};

export type RunApiStartRequest = {
  /**
   * Your project name. It is the name you provide when creating a project.
   */
  projectName: string;
  /**
   * Run API input schema
   */
  requestBody: RunApiStartRequestBody;
};

export const Status = {
  Pending: "pending",
} as const;
export type Status = ClosedEnum<typeof Status>;

/**
 * Object with user data.
 */
export type RunApiStartResponseBody = {
  /**
   * Unique identifier for the run, nanoId of 21 characters
   */
  runId: string;
  status: Status;
};

/** @internal */
export const RunApiStartGlobals$inboundSchema: z.ZodType<
  RunApiStartGlobals,
  z.ZodTypeDef,
  unknown
> = z.object({
  workspaceId: z.string().optional(),
});

/** @internal */
export type RunApiStartGlobals$Outbound = {
  workspaceId?: string | undefined;
};

/** @internal */
export const RunApiStartGlobals$outboundSchema: z.ZodType<
  RunApiStartGlobals$Outbound,
  z.ZodTypeDef,
  RunApiStartGlobals
> = z.object({
  workspaceId: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RunApiStartGlobals$ {
  /** @deprecated use `RunApiStartGlobals$inboundSchema` instead. */
  export const inboundSchema = RunApiStartGlobals$inboundSchema;
  /** @deprecated use `RunApiStartGlobals$outboundSchema` instead. */
  export const outboundSchema = RunApiStartGlobals$outboundSchema;
  /** @deprecated use `RunApiStartGlobals$Outbound` instead. */
  export type Outbound = RunApiStartGlobals$Outbound;
}

export function runApiStartGlobalsToJSON(
  runApiStartGlobals: RunApiStartGlobals,
): string {
  return JSON.stringify(
    RunApiStartGlobals$outboundSchema.parse(runApiStartGlobals),
  );
}

export function runApiStartGlobalsFromJSON(
  jsonString: string,
): SafeParseResult<RunApiStartGlobals, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunApiStartGlobals$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunApiStartGlobals' from JSON`,
  );
}

/** @internal */
export const Retry$inboundSchema: z.ZodType<Retry, z.ZodTypeDef, unknown> = z
  .object({
    maximumAttempts: z.number().int().default(3),
  });

/** @internal */
export type Retry$Outbound = {
  maximumAttempts: number;
};

/** @internal */
export const Retry$outboundSchema: z.ZodType<
  Retry$Outbound,
  z.ZodTypeDef,
  Retry
> = z.object({
  maximumAttempts: z.number().int().default(3),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Retry$ {
  /** @deprecated use `Retry$inboundSchema` instead. */
  export const inboundSchema = Retry$inboundSchema;
  /** @deprecated use `Retry$outboundSchema` instead. */
  export const outboundSchema = Retry$outboundSchema;
  /** @deprecated use `Retry$Outbound` instead. */
  export type Outbound = Retry$Outbound;
}

export function retryToJSON(retry: Retry): string {
  return JSON.stringify(Retry$outboundSchema.parse(retry));
}

export function retryFromJSON(
  jsonString: string,
): SafeParseResult<Retry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Retry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Retry' from JSON`,
  );
}

/** @internal */
export const Two$inboundSchema: z.ZodType<Two, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string().optional(),
    autoRecreate: z.boolean().default(true),
    checkAttempts: z.number().int().default(3),
    createAttempts: z.number().int().default(3),
    proxy: z.string().optional(),
    requestTimeout: z.number().int().default(600),
    runtimeInput: z.record(z.any()),
  });

/** @internal */
export type Two$Outbound = {
  id?: string | undefined;
  autoRecreate: boolean;
  checkAttempts: number;
  createAttempts: number;
  proxy?: string | undefined;
  requestTimeout: number;
  runtimeInput: { [k: string]: any };
};

/** @internal */
export const Two$outboundSchema: z.ZodType<Two$Outbound, z.ZodTypeDef, Two> = z
  .object({
    id: z.string().optional(),
    autoRecreate: z.boolean().default(true),
    checkAttempts: z.number().int().default(3),
    createAttempts: z.number().int().default(3),
    proxy: z.string().optional(),
    requestTimeout: z.number().int().default(600),
    runtimeInput: z.record(z.any()),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Two$ {
  /** @deprecated use `Two$inboundSchema` instead. */
  export const inboundSchema = Two$inboundSchema;
  /** @deprecated use `Two$outboundSchema` instead. */
  export const outboundSchema = Two$outboundSchema;
  /** @deprecated use `Two$Outbound` instead. */
  export type Outbound = Two$Outbound;
}

export function twoToJSON(two: Two): string {
  return JSON.stringify(Two$outboundSchema.parse(two));
}

export function twoFromJSON(
  jsonString: string,
): SafeParseResult<Two, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Two$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Two' from JSON`,
  );
}

/** @internal */
export const One$inboundSchema: z.ZodType<One, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    autoRecreate: z.boolean().default(true),
    checkAttempts: z.number().int().default(3),
    createAttempts: z.number().int().default(3),
    proxy: z.string().optional(),
    requestTimeout: z.number().int().default(600),
  });

/** @internal */
export type One$Outbound = {
  id: string;
  autoRecreate: boolean;
  checkAttempts: number;
  createAttempts: number;
  proxy?: string | undefined;
  requestTimeout: number;
};

/** @internal */
export const One$outboundSchema: z.ZodType<One$Outbound, z.ZodTypeDef, One> = z
  .object({
    id: z.string(),
    autoRecreate: z.boolean().default(true),
    checkAttempts: z.number().int().default(3),
    createAttempts: z.number().int().default(3),
    proxy: z.string().optional(),
    requestTimeout: z.number().int().default(600),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace One$ {
  /** @deprecated use `One$inboundSchema` instead. */
  export const inboundSchema = One$inboundSchema;
  /** @deprecated use `One$outboundSchema` instead. */
  export const outboundSchema = One$outboundSchema;
  /** @deprecated use `One$Outbound` instead. */
  export type Outbound = One$Outbound;
}

export function oneToJSON(one: One): string {
  return JSON.stringify(One$outboundSchema.parse(one));
}

export function oneFromJSON(
  jsonString: string,
): SafeParseResult<One, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => One$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'One' from JSON`,
  );
}

/** @internal */
export const AuthSession$inboundSchema: z.ZodType<
  AuthSession,
  z.ZodTypeDef,
  unknown
> = z.union([z.lazy(() => One$inboundSchema), z.lazy(() => Two$inboundSchema)]);

/** @internal */
export type AuthSession$Outbound = One$Outbound | Two$Outbound;

/** @internal */
export const AuthSession$outboundSchema: z.ZodType<
  AuthSession$Outbound,
  z.ZodTypeDef,
  AuthSession
> = z.union([
  z.lazy(() => One$outboundSchema),
  z.lazy(() => Two$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthSession$ {
  /** @deprecated use `AuthSession$inboundSchema` instead. */
  export const inboundSchema = AuthSession$inboundSchema;
  /** @deprecated use `AuthSession$outboundSchema` instead. */
  export const outboundSchema = AuthSession$outboundSchema;
  /** @deprecated use `AuthSession$Outbound` instead. */
  export type Outbound = AuthSession$Outbound;
}

export function authSessionToJSON(authSession: AuthSession): string {
  return JSON.stringify(AuthSession$outboundSchema.parse(authSession));
}

export function authSessionFromJSON(
  jsonString: string,
): SafeParseResult<AuthSession, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthSession$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthSession' from JSON`,
  );
}

/** @internal */
export const SinkType$inboundSchema: z.ZodNativeEnum<typeof SinkType> = z
  .nativeEnum(SinkType);

/** @internal */
export const SinkType$outboundSchema: z.ZodNativeEnum<typeof SinkType> =
  SinkType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SinkType$ {
  /** @deprecated use `SinkType$inboundSchema` instead. */
  export const inboundSchema = SinkType$inboundSchema;
  /** @deprecated use `SinkType$outboundSchema` instead. */
  export const outboundSchema = SinkType$outboundSchema;
}

/** @internal */
export const S3SinkConfiguration$inboundSchema: z.ZodType<
  S3SinkConfiguration,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: SinkType$inboundSchema,
  bucket: z.string(),
  accessKeyId: z.string(),
  secretAccessKey: z.string(),
  region: z.string(),
  prefix: z.string().optional(),
  skipOnFail: z.boolean().default(false),
  apisToSend: z.array(z.string()).optional(),
  endpoint: z.string().optional(),
  forcePathStyle: z.boolean().optional(),
});

/** @internal */
export type S3SinkConfiguration$Outbound = {
  type: string;
  bucket: string;
  accessKeyId: string;
  secretAccessKey: string;
  region: string;
  prefix?: string | undefined;
  skipOnFail: boolean;
  apisToSend?: Array<string> | undefined;
  endpoint?: string | undefined;
  forcePathStyle?: boolean | undefined;
};

/** @internal */
export const S3SinkConfiguration$outboundSchema: z.ZodType<
  S3SinkConfiguration$Outbound,
  z.ZodTypeDef,
  S3SinkConfiguration
> = z.object({
  type: SinkType$outboundSchema,
  bucket: z.string(),
  accessKeyId: z.string(),
  secretAccessKey: z.string(),
  region: z.string(),
  prefix: z.string().optional(),
  skipOnFail: z.boolean().default(false),
  apisToSend: z.array(z.string()).optional(),
  endpoint: z.string().optional(),
  forcePathStyle: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace S3SinkConfiguration$ {
  /** @deprecated use `S3SinkConfiguration$inboundSchema` instead. */
  export const inboundSchema = S3SinkConfiguration$inboundSchema;
  /** @deprecated use `S3SinkConfiguration$outboundSchema` instead. */
  export const outboundSchema = S3SinkConfiguration$outboundSchema;
  /** @deprecated use `S3SinkConfiguration$Outbound` instead. */
  export type Outbound = S3SinkConfiguration$Outbound;
}

export function s3SinkConfigurationToJSON(
  s3SinkConfiguration: S3SinkConfiguration,
): string {
  return JSON.stringify(
    S3SinkConfiguration$outboundSchema.parse(s3SinkConfiguration),
  );
}

export function s3SinkConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<S3SinkConfiguration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => S3SinkConfiguration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'S3SinkConfiguration' from JSON`,
  );
}

/** @internal */
export const Type$inboundSchema: z.ZodNativeEnum<typeof Type> = z.nativeEnum(
  Type,
);

/** @internal */
export const Type$outboundSchema: z.ZodNativeEnum<typeof Type> =
  Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Type$ {
  /** @deprecated use `Type$inboundSchema` instead. */
  export const inboundSchema = Type$inboundSchema;
  /** @deprecated use `Type$outboundSchema` instead. */
  export const outboundSchema = Type$outboundSchema;
}

/** @internal */
export const WebhookSinkConfiguration$inboundSchema: z.ZodType<
  WebhookSinkConfiguration,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: Type$inboundSchema,
  url: z.string(),
  headers: z.record(z.string()).optional(),
  skipOnFail: z.boolean().default(false),
  apisToSend: z.array(z.string()).optional(),
});

/** @internal */
export type WebhookSinkConfiguration$Outbound = {
  type: string;
  url: string;
  headers?: { [k: string]: string } | undefined;
  skipOnFail: boolean;
  apisToSend?: Array<string> | undefined;
};

/** @internal */
export const WebhookSinkConfiguration$outboundSchema: z.ZodType<
  WebhookSinkConfiguration$Outbound,
  z.ZodTypeDef,
  WebhookSinkConfiguration
> = z.object({
  type: Type$outboundSchema,
  url: z.string(),
  headers: z.record(z.string()).optional(),
  skipOnFail: z.boolean().default(false),
  apisToSend: z.array(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WebhookSinkConfiguration$ {
  /** @deprecated use `WebhookSinkConfiguration$inboundSchema` instead. */
  export const inboundSchema = WebhookSinkConfiguration$inboundSchema;
  /** @deprecated use `WebhookSinkConfiguration$outboundSchema` instead. */
  export const outboundSchema = WebhookSinkConfiguration$outboundSchema;
  /** @deprecated use `WebhookSinkConfiguration$Outbound` instead. */
  export type Outbound = WebhookSinkConfiguration$Outbound;
}

export function webhookSinkConfigurationToJSON(
  webhookSinkConfiguration: WebhookSinkConfiguration,
): string {
  return JSON.stringify(
    WebhookSinkConfiguration$outboundSchema.parse(webhookSinkConfiguration),
  );
}

export function webhookSinkConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<WebhookSinkConfiguration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WebhookSinkConfiguration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WebhookSinkConfiguration' from JSON`,
  );
}

/** @internal */
export const Sink$inboundSchema: z.ZodType<Sink, z.ZodTypeDef, unknown> = z
  .union([
    z.lazy(() => S3SinkConfiguration$inboundSchema),
    z.lazy(() => WebhookSinkConfiguration$inboundSchema),
  ]);

/** @internal */
export type Sink$Outbound =
  | S3SinkConfiguration$Outbound
  | WebhookSinkConfiguration$Outbound;

/** @internal */
export const Sink$outboundSchema: z.ZodType<Sink$Outbound, z.ZodTypeDef, Sink> =
  z.union([
    z.lazy(() => S3SinkConfiguration$outboundSchema),
    z.lazy(() => WebhookSinkConfiguration$outboundSchema),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Sink$ {
  /** @deprecated use `Sink$inboundSchema` instead. */
  export const inboundSchema = Sink$inboundSchema;
  /** @deprecated use `Sink$outboundSchema` instead. */
  export const outboundSchema = Sink$outboundSchema;
  /** @deprecated use `Sink$Outbound` instead. */
  export type Outbound = Sink$Outbound;
}

export function sinkToJSON(sink: Sink): string {
  return JSON.stringify(Sink$outboundSchema.parse(sink));
}

export function sinkFromJSON(
  jsonString: string,
): SafeParseResult<Sink, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Sink$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Sink' from JSON`,
  );
}

/** @internal */
export const RunApiStartRequestBody$inboundSchema: z.ZodType<
  RunApiStartRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  parameters: z.record(z.any()),
  proxy: z.string().optional(),
  saveTrace: z.boolean().default(true),
  requestTimeout: z.number().int().default(600),
  retry: z.lazy(() => Retry$inboundSchema).optional(),
  authSession: z.union([
    z.lazy(() => One$inboundSchema),
    z.lazy(() => Two$inboundSchema),
  ]).optional(),
  sink: z.union([
    z.lazy(() => S3SinkConfiguration$inboundSchema),
    z.lazy(() => WebhookSinkConfiguration$inboundSchema),
  ]).optional(),
  api: z.string(),
});

/** @internal */
export type RunApiStartRequestBody$Outbound = {
  parameters: { [k: string]: any };
  proxy?: string | undefined;
  saveTrace: boolean;
  requestTimeout: number;
  retry?: Retry$Outbound | undefined;
  authSession?: One$Outbound | Two$Outbound | undefined;
  sink?:
    | S3SinkConfiguration$Outbound
    | WebhookSinkConfiguration$Outbound
    | undefined;
  api: string;
};

/** @internal */
export const RunApiStartRequestBody$outboundSchema: z.ZodType<
  RunApiStartRequestBody$Outbound,
  z.ZodTypeDef,
  RunApiStartRequestBody
> = z.object({
  parameters: z.record(z.any()),
  proxy: z.string().optional(),
  saveTrace: z.boolean().default(true),
  requestTimeout: z.number().int().default(600),
  retry: z.lazy(() => Retry$outboundSchema).optional(),
  authSession: z.union([
    z.lazy(() => One$outboundSchema),
    z.lazy(() => Two$outboundSchema),
  ]).optional(),
  sink: z.union([
    z.lazy(() => S3SinkConfiguration$outboundSchema),
    z.lazy(() => WebhookSinkConfiguration$outboundSchema),
  ]).optional(),
  api: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RunApiStartRequestBody$ {
  /** @deprecated use `RunApiStartRequestBody$inboundSchema` instead. */
  export const inboundSchema = RunApiStartRequestBody$inboundSchema;
  /** @deprecated use `RunApiStartRequestBody$outboundSchema` instead. */
  export const outboundSchema = RunApiStartRequestBody$outboundSchema;
  /** @deprecated use `RunApiStartRequestBody$Outbound` instead. */
  export type Outbound = RunApiStartRequestBody$Outbound;
}

export function runApiStartRequestBodyToJSON(
  runApiStartRequestBody: RunApiStartRequestBody,
): string {
  return JSON.stringify(
    RunApiStartRequestBody$outboundSchema.parse(runApiStartRequestBody),
  );
}

export function runApiStartRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<RunApiStartRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunApiStartRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunApiStartRequestBody' from JSON`,
  );
}

/** @internal */
export const RunApiStartRequest$inboundSchema: z.ZodType<
  RunApiStartRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  projectName: z.string(),
  RequestBody: z.lazy(() => RunApiStartRequestBody$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type RunApiStartRequest$Outbound = {
  projectName: string;
  RequestBody: RunApiStartRequestBody$Outbound;
};

/** @internal */
export const RunApiStartRequest$outboundSchema: z.ZodType<
  RunApiStartRequest$Outbound,
  z.ZodTypeDef,
  RunApiStartRequest
> = z.object({
  projectName: z.string(),
  requestBody: z.lazy(() => RunApiStartRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RunApiStartRequest$ {
  /** @deprecated use `RunApiStartRequest$inboundSchema` instead. */
  export const inboundSchema = RunApiStartRequest$inboundSchema;
  /** @deprecated use `RunApiStartRequest$outboundSchema` instead. */
  export const outboundSchema = RunApiStartRequest$outboundSchema;
  /** @deprecated use `RunApiStartRequest$Outbound` instead. */
  export type Outbound = RunApiStartRequest$Outbound;
}

export function runApiStartRequestToJSON(
  runApiStartRequest: RunApiStartRequest,
): string {
  return JSON.stringify(
    RunApiStartRequest$outboundSchema.parse(runApiStartRequest),
  );
}

export function runApiStartRequestFromJSON(
  jsonString: string,
): SafeParseResult<RunApiStartRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunApiStartRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunApiStartRequest' from JSON`,
  );
}

/** @internal */
export const Status$inboundSchema: z.ZodNativeEnum<typeof Status> = z
  .nativeEnum(Status);

/** @internal */
export const Status$outboundSchema: z.ZodNativeEnum<typeof Status> =
  Status$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Status$ {
  /** @deprecated use `Status$inboundSchema` instead. */
  export const inboundSchema = Status$inboundSchema;
  /** @deprecated use `Status$outboundSchema` instead. */
  export const outboundSchema = Status$outboundSchema;
}

/** @internal */
export const RunApiStartResponseBody$inboundSchema: z.ZodType<
  RunApiStartResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  runId: z.string(),
  status: Status$inboundSchema,
});

/** @internal */
export type RunApiStartResponseBody$Outbound = {
  runId: string;
  status: string;
};

/** @internal */
export const RunApiStartResponseBody$outboundSchema: z.ZodType<
  RunApiStartResponseBody$Outbound,
  z.ZodTypeDef,
  RunApiStartResponseBody
> = z.object({
  runId: z.string(),
  status: Status$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RunApiStartResponseBody$ {
  /** @deprecated use `RunApiStartResponseBody$inboundSchema` instead. */
  export const inboundSchema = RunApiStartResponseBody$inboundSchema;
  /** @deprecated use `RunApiStartResponseBody$outboundSchema` instead. */
  export const outboundSchema = RunApiStartResponseBody$outboundSchema;
  /** @deprecated use `RunApiStartResponseBody$Outbound` instead. */
  export type Outbound = RunApiStartResponseBody$Outbound;
}

export function runApiStartResponseBodyToJSON(
  runApiStartResponseBody: RunApiStartResponseBody,
): string {
  return JSON.stringify(
    RunApiStartResponseBody$outboundSchema.parse(runApiStartResponseBody),
  );
}

export function runApiStartResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<RunApiStartResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunApiStartResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunApiStartResponseBody' from JSON`,
  );
}
