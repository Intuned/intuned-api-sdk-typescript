/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type GetJobRunGlobals = {
  /**
   * Your workspace ID. [How to find it](/docs/03-how-to/manage/manage-workspace#how-to-get-your-workspace-id)?
   */
  workspaceId?: string | undefined;
};

export type GetJobRunRequest = {
  /**
   * The name you assigned when creating the Project.
   */
  projectName: string;
  /**
   * The ID you assigned when creating the Job.
   */
  jobId: string;
  /**
   * The job run ID. This can be obtained from the get job runs endpoint or from the result of the trigger endpoint for a job.
   */
  jobRunId: string;
};

/**
 * Type of the JobRun.
 */
export const GetJobRunType = {
  Manual: "MANUAL",
  Scheduled: "SCHEDULED",
} as const;
/**
 * Type of the JobRun.
 */
export type GetJobRunType = ClosedEnum<typeof GetJobRunType>;

/**
 * Current status of the JobRun.
 */
export const GetJobRunStatus = {
  Canceled: "CANCELED",
  Pending: "PENDING",
  Paused: "PAUSED",
  Pausing: "PAUSING",
  Resuming: "RESUMING",
  Success: "SUCCESS",
  Failure: "FAILURE",
  Terminated: "TERMINATED",
  Completed: "COMPLETED",
} as const;
/**
 * Current status of the JobRun.
 */
export type GetJobRunStatus = ClosedEnum<typeof GetJobRunStatus>;

/**
 * Optional error code for more specific error identification
 */
export const GetJobRunCode = {
  InternalServerError: "internal-server-error",
  InsufficientResourceCredits: "insufficient-resource-credits",
} as const;
/**
 * Optional error code for more specific error identification
 */
export type GetJobRunCode = ClosedEnum<typeof GetJobRunCode>;

export const GetJobRunCategory = {
  Billing: "billing",
  Infrastructure: "infrastructure",
} as const;
export type GetJobRunCategory = ClosedEnum<typeof GetJobRunCategory>;

/**
 * Error information if the job run failed, stored as JSONB
 */
export type GetJobRunError = {
  /**
   * Error message describing the failure
   */
  message: string;
  /**
   * Optional error code for more specific error identification
   */
  code: GetJobRunCode;
  details?: any | undefined;
  category: GetJobRunCategory;
  /**
   * Optional correlation ID for tracking the error
   */
  correlationId?: string | undefined;
  retirable: boolean;
  /**
   * Optional documentation URL for more information
   */
  docUrl?: string | undefined;
};

export const GetJobRunProjectJobsRunsType = {
  Terminated: "terminated",
  UserRequest: "user-request",
  AuthSessionNotFound: "auth-session-not-found",
  AuthSessionInvalidMidJob: "auth-session-invalid-mid-job",
  AuthSessionValidateDependencyFailed:
    "auth-session-validate-dependency-failed",
  AuthSessionLocked: "auth-session-locked",
  AnotherJobRunActive: "another-job-run-active",
  InsufficientResourceCredits: "insufficient-resource-credits",
  S3SinkError: "s3-sink-error",
} as const;
export type GetJobRunProjectJobsRunsType = ClosedEnum<
  typeof GetJobRunProjectJobsRunsType
>;

/**
 * Reason for JobRun state change., stored as JSONB
 */
export type GetJobRunReason = {
  type: GetJobRunProjectJobsRunsType;
  message: string;
  details?: any | undefined;
  /**
   * Optional documentation URL for more information
   */
  docUrl?: string | undefined;
};

/**
 * The retry policy of the job. Configure how many retries and the delay between them for each payload.
 */
export type GetJobRunRetry = {
  /**
   * Maximum number of attempts to retry the run in case of failure
   */
  maximumAttempts: number;
};

/**
 * Job configuration settings
 */
export type GetJobRunConfiguration = {
  /**
   * The retry policy of the job. Configure how many retries and the delay between them for each payload.
   */
  retry?: GetJobRunRetry | undefined;
  /**
   * The batch size of payloads to execute. This does not guarantee that the payloads will be executed at the same time.
   */
  maxConcurrentRequests?: number | undefined;
  /**
   * Timeout for the API request in seconds. Default is 10 minutes (600 seconds).
   */
  requestTimeout: number;
};

/**
 * Configuration for the S3 sink.
 */
export type GetJobRunSinkS3SinkConfiguration = {
  type: "s3";
  /**
   * The name of the S3 bucket where the data will be stored.
   */
  bucket: string;
  /**
   * The access key ID for the S3 bucket.
   */
  accessKeyId: string;
  /**
   * The secret access key for the S3 bucket.
   */
  secretAccessKey: string;
  /**
   * The region where the S3 bucket is located.
   */
  region: string;
  /**
   * Optional prefix for the S3 objects. This can be used to organize objects within the bucket.
   */
  prefix?: string | undefined;
  /**
   * If enabled, failed payload runs will ***not*** be written to the bucket.
   */
  skipOnFail: boolean;
  /**
   * List of API names to be sent to the S3 bucket. If not provided, all APIs will be sent.
   */
  apisToSend?: Array<string> | undefined;
  /**
   * Optional custom endpoint for the S3 bucket. This can be used for S3-compatible services.
   */
  endpoint?: string | undefined;
  /**
   * If true, the S3 client will use path-style URLs instead of virtual-hosted-style URLs. This is useful for S3-compatible services that require path-style access.
   */
  forcePathStyle?: boolean | undefined;
};

/**
 * Configuration for the webhook sink.
 */
export type GetJobRunSinkWebhookSinkConfiguration = {
  type: "webhook";
  /**
   * The URL to which the webhook will send the data.
   */
  url: string;
  /**
   * Optional headers to be sent with the webhook request.
   */
  headers?: { [k: string]: string } | undefined;
  /**
   * If true, the webhook will not be sent if the API execution fails.
   */
  skipOnFail: boolean;
  /**
   * List of API names to be sent to the webhook. If not provided, all APIs will be sent.
   */
  apisToSend?: Array<string> | undefined;
};

/**
 * Optional sink configuration for the job. Can be a webhook or S3 Compatible sink.
 */
export type GetJobRunSink =
  | GetJobRunSinkWebhookSinkConfiguration
  | GetJobRunSinkS3SinkConfiguration;

/**
 * Authentication session information for the job
 */
export type GetJobRunAuthSession = {
  id: string;
  /**
   * Number of attempts to check the validity of the auth session before recreating it.
   */
  checkAttempts: number;
  /**
   * Number of attempts to create a new auth session if the current one is invalid or expired.
   */
  createAttempts: number;
};

export const GetJobRunVersion = {
  V1: "v1",
} as const;
export type GetJobRunVersion = ClosedEnum<typeof GetJobRunVersion>;

/**
 * Proxy configuration for the job, stored as JSONB
 */
export type GetJobRunProxy = {
  version: GetJobRunVersion;
  url: string;
};

/**
 * Snapshot of job configuration at the time of the job run
 */
export type GetJobRunJobConfigurationSnapshot = {
  /**
   * Job configuration settings
   */
  configuration: GetJobRunConfiguration;
  /**
   * Optional sink configuration for the job. Can be a webhook or S3 Compatible sink.
   */
  sink?:
    | GetJobRunSinkWebhookSinkConfiguration
    | GetJobRunSinkS3SinkConfiguration
    | null
    | undefined;
  /**
   * Authentication session information for the job
   */
  authSession?: GetJobRunAuthSession | null | undefined;
  /**
   * Proxy configuration for the job, stored as JSONB
   */
  proxy?: GetJobRunProxy | null | undefined;
};

export type JobRun = {
  /**
   * Unique identifier for the JobRun.
   */
  id: string;
  /**
   * Timestamp when the JobRun started.
   */
  startTime: string;
  /**
   * Timestamp when the job run ended (null if still running)
   */
  endTime: string | null;
  /**
   * UUID of the workspace this JobRun belongs to.
   */
  workspaceId: string;
  /**
   * UUID of the project this JobRun belongs to.
   */
  projectId: string;
  /**
   * ID of the job this run belongs to
   */
  jobId: string;
  /**
   * Timestamp when the JobRun was created.
   */
  createdAt: string;
  /**
   * Timestamp when the JobRun was last updated.
   */
  updatedAt: string;
  /**
   * Type of the JobRun.
   */
  type: GetJobRunType;
  /**
   * Current status of the JobRun.
   */
  status: GetJobRunStatus;
  /**
   * Total number of payloads in the JobRun.
   */
  payloads: number | null;
  /**
   * Number of successful API calls in the JobRun.
   */
  successfulRuns: number | null;
  /**
   * Number of failed API calls in the JobRun.
   */
  failedRuns: number | null;
  /**
   * Error information if the job run failed, stored as JSONB
   */
  error?: GetJobRunError | null | undefined;
  /**
   * Reason for JobRun state change., stored as JSONB
   */
  reason?: GetJobRunReason | null | undefined;
  /**
   * Snapshot of job configuration at the time of the job run
   */
  jobConfigurationSnapshot: GetJobRunJobConfigurationSnapshot;
};

export type Results = {
  signedUrl: string;
  signedUrlExpiration?: string | undefined;
  size?: number | undefined;
  key?: string | undefined;
  format: string;
};

/**
 * JobRun information and results.
 */
export type GetJobRunResponseBody = {
  jobRun: JobRun;
  results?: Results | undefined;
};

/** @internal */
export type GetJobRunRequest$Outbound = {
  projectName: string;
  jobId: string;
  jobRunId: string;
};

/** @internal */
export const GetJobRunRequest$outboundSchema: z.ZodType<
  GetJobRunRequest$Outbound,
  z.ZodTypeDef,
  GetJobRunRequest
> = z.object({
  projectName: z.string(),
  jobId: z.string(),
  jobRunId: z.string(),
});

export function getJobRunRequestToJSON(
  getJobRunRequest: GetJobRunRequest,
): string {
  return JSON.stringify(
    GetJobRunRequest$outboundSchema.parse(getJobRunRequest),
  );
}

/** @internal */
export const GetJobRunType$inboundSchema: z.ZodNativeEnum<
  typeof GetJobRunType
> = z.nativeEnum(GetJobRunType);

/** @internal */
export const GetJobRunStatus$inboundSchema: z.ZodNativeEnum<
  typeof GetJobRunStatus
> = z.nativeEnum(GetJobRunStatus);

/** @internal */
export const GetJobRunCode$inboundSchema: z.ZodNativeEnum<
  typeof GetJobRunCode
> = z.nativeEnum(GetJobRunCode);

/** @internal */
export const GetJobRunCategory$inboundSchema: z.ZodNativeEnum<
  typeof GetJobRunCategory
> = z.nativeEnum(GetJobRunCategory);

/** @internal */
export const GetJobRunError$inboundSchema: z.ZodType<
  GetJobRunError,
  z.ZodTypeDef,
  unknown
> = z.object({
  message: z.string(),
  code: GetJobRunCode$inboundSchema,
  details: z.any().optional(),
  category: GetJobRunCategory$inboundSchema,
  correlationId: z.string().optional(),
  retirable: z.boolean().default(false),
  doc_url: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "doc_url": "docUrl",
  });
});

export function getJobRunErrorFromJSON(
  jsonString: string,
): SafeParseResult<GetJobRunError, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetJobRunError$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetJobRunError' from JSON`,
  );
}

/** @internal */
export const GetJobRunProjectJobsRunsType$inboundSchema: z.ZodNativeEnum<
  typeof GetJobRunProjectJobsRunsType
> = z.nativeEnum(GetJobRunProjectJobsRunsType);

/** @internal */
export const GetJobRunReason$inboundSchema: z.ZodType<
  GetJobRunReason,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: GetJobRunProjectJobsRunsType$inboundSchema,
  message: z.string(),
  details: z.any().optional(),
  doc_url: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "doc_url": "docUrl",
  });
});

export function getJobRunReasonFromJSON(
  jsonString: string,
): SafeParseResult<GetJobRunReason, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetJobRunReason$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetJobRunReason' from JSON`,
  );
}

/** @internal */
export const GetJobRunRetry$inboundSchema: z.ZodType<
  GetJobRunRetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  maximumAttempts: z.number().int().default(3),
});

export function getJobRunRetryFromJSON(
  jsonString: string,
): SafeParseResult<GetJobRunRetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetJobRunRetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetJobRunRetry' from JSON`,
  );
}

/** @internal */
export const GetJobRunConfiguration$inboundSchema: z.ZodType<
  GetJobRunConfiguration,
  z.ZodTypeDef,
  unknown
> = z.object({
  retry: z.lazy(() => GetJobRunRetry$inboundSchema).optional(),
  maxConcurrentRequests: z.number().optional(),
  requestTimeout: z.number().int().default(600),
});

export function getJobRunConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<GetJobRunConfiguration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetJobRunConfiguration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetJobRunConfiguration' from JSON`,
  );
}

/** @internal */
export const GetJobRunSinkS3SinkConfiguration$inboundSchema: z.ZodType<
  GetJobRunSinkS3SinkConfiguration,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("s3"),
  bucket: z.string(),
  accessKeyId: z.string(),
  secretAccessKey: z.string(),
  region: z.string(),
  prefix: z.string().optional(),
  skipOnFail: z.boolean().default(false),
  apisToSend: z.array(z.string()).optional(),
  endpoint: z.string().optional(),
  forcePathStyle: z.boolean().optional(),
});

export function getJobRunSinkS3SinkConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<GetJobRunSinkS3SinkConfiguration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetJobRunSinkS3SinkConfiguration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetJobRunSinkS3SinkConfiguration' from JSON`,
  );
}

/** @internal */
export const GetJobRunSinkWebhookSinkConfiguration$inboundSchema: z.ZodType<
  GetJobRunSinkWebhookSinkConfiguration,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("webhook"),
  url: z.string(),
  headers: z.record(z.string()).optional(),
  skipOnFail: z.boolean().default(false),
  apisToSend: z.array(z.string()).optional(),
});

export function getJobRunSinkWebhookSinkConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<GetJobRunSinkWebhookSinkConfiguration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetJobRunSinkWebhookSinkConfiguration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetJobRunSinkWebhookSinkConfiguration' from JSON`,
  );
}

/** @internal */
export const GetJobRunSink$inboundSchema: z.ZodType<
  GetJobRunSink,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => GetJobRunSinkWebhookSinkConfiguration$inboundSchema),
  z.lazy(() => GetJobRunSinkS3SinkConfiguration$inboundSchema),
]);

export function getJobRunSinkFromJSON(
  jsonString: string,
): SafeParseResult<GetJobRunSink, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetJobRunSink$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetJobRunSink' from JSON`,
  );
}

/** @internal */
export const GetJobRunAuthSession$inboundSchema: z.ZodType<
  GetJobRunAuthSession,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  checkAttempts: z.number().int().default(3),
  createAttempts: z.number().int().default(3),
});

export function getJobRunAuthSessionFromJSON(
  jsonString: string,
): SafeParseResult<GetJobRunAuthSession, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetJobRunAuthSession$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetJobRunAuthSession' from JSON`,
  );
}

/** @internal */
export const GetJobRunVersion$inboundSchema: z.ZodNativeEnum<
  typeof GetJobRunVersion
> = z.nativeEnum(GetJobRunVersion);

/** @internal */
export const GetJobRunProxy$inboundSchema: z.ZodType<
  GetJobRunProxy,
  z.ZodTypeDef,
  unknown
> = z.object({
  version: GetJobRunVersion$inboundSchema,
  url: z.string(),
});

export function getJobRunProxyFromJSON(
  jsonString: string,
): SafeParseResult<GetJobRunProxy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetJobRunProxy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetJobRunProxy' from JSON`,
  );
}

/** @internal */
export const GetJobRunJobConfigurationSnapshot$inboundSchema: z.ZodType<
  GetJobRunJobConfigurationSnapshot,
  z.ZodTypeDef,
  unknown
> = z.object({
  configuration: z.lazy(() => GetJobRunConfiguration$inboundSchema),
  sink: z.nullable(
    z.union([
      z.lazy(() => GetJobRunSinkWebhookSinkConfiguration$inboundSchema),
      z.lazy(() => GetJobRunSinkS3SinkConfiguration$inboundSchema),
    ]),
  ).optional(),
  auth_session: z.nullable(z.lazy(() => GetJobRunAuthSession$inboundSchema))
    .optional(),
  proxy: z.nullable(z.lazy(() => GetJobRunProxy$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "auth_session": "authSession",
  });
});

export function getJobRunJobConfigurationSnapshotFromJSON(
  jsonString: string,
): SafeParseResult<GetJobRunJobConfigurationSnapshot, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetJobRunJobConfigurationSnapshot$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetJobRunJobConfigurationSnapshot' from JSON`,
  );
}

/** @internal */
export const JobRun$inboundSchema: z.ZodType<JobRun, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    start_time: z.string(),
    end_time: z.nullable(z.string()),
    workspace_id: z.string(),
    project_id: z.string(),
    job_id: z.string(),
    created_at: z.string(),
    updated_at: z.string(),
    type: GetJobRunType$inboundSchema,
    status: GetJobRunStatus$inboundSchema,
    payloads: z.nullable(z.number().int()),
    successful_runs: z.nullable(z.number().int()),
    failed_runs: z.nullable(z.number().int()),
    error: z.nullable(z.lazy(() => GetJobRunError$inboundSchema)).optional(),
    reason: z.nullable(z.lazy(() => GetJobRunReason$inboundSchema)).optional(),
    job_configuration_snapshot: z.lazy(() =>
      GetJobRunJobConfigurationSnapshot$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "start_time": "startTime",
      "end_time": "endTime",
      "workspace_id": "workspaceId",
      "project_id": "projectId",
      "job_id": "jobId",
      "created_at": "createdAt",
      "updated_at": "updatedAt",
      "successful_runs": "successfulRuns",
      "failed_runs": "failedRuns",
      "job_configuration_snapshot": "jobConfigurationSnapshot",
    });
  });

export function jobRunFromJSON(
  jsonString: string,
): SafeParseResult<JobRun, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => JobRun$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'JobRun' from JSON`,
  );
}

/** @internal */
export const Results$inboundSchema: z.ZodType<Results, z.ZodTypeDef, unknown> =
  z.object({
    signed_url: z.string(),
    signed_url_expiration: z.string().optional(),
    size: z.number().optional(),
    key: z.string().optional(),
    format: z.string(),
  }).transform((v) => {
    return remap$(v, {
      "signed_url": "signedUrl",
      "signed_url_expiration": "signedUrlExpiration",
    });
  });

export function resultsFromJSON(
  jsonString: string,
): SafeParseResult<Results, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Results$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Results' from JSON`,
  );
}

/** @internal */
export const GetJobRunResponseBody$inboundSchema: z.ZodType<
  GetJobRunResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  jobRun: z.lazy(() => JobRun$inboundSchema),
  results: z.lazy(() => Results$inboundSchema).optional(),
});

export function getJobRunResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<GetJobRunResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetJobRunResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetJobRunResponseBody' from JSON`,
  );
}
